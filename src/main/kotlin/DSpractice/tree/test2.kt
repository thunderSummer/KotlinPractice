package DSpractice.tree

fun main(args : Array<String>){
    val tree = BinaryTree<Int>()
//    val root = BinaryNode(1)
//    tree.insert(root)
//    tree.insert(BinaryNode(2))
//    tree.insert(BinaryNode(3))
//    tree.insert(BinaryNode(4))
//    tree.insert(BinaryNode(5))
//    tree.insert(null)
//    tree.insert(BinaryNode(9))
//    tree.insert(null)
//    tree.insert(null)
//    tree.insert(BinaryNode(6))
//    tree.insert(BinaryNode(8))
//    tree.insert(BinaryNode(10))
//    tree.insert(null)
//    tree.insert(null)
//    tree.insert(BinaryNode(7))
//    tree.insert(null)
//    tree.insert(null)
//    tree.insert(BinaryNode(11))
//    tree.insert(BinaryNode(12))
//    println("ss")
//    tree.orderTree(root,BinaryTree.BinaryType.LEVEL)
//    println()
//    tree.orderTree(root,BinaryTree.BinaryType.PREVIOUS)
//    println()
//    tree.orderTree(root,BinaryTree.BinaryType.POST)
//    println()
//    println(tree.getNodeNum(2,root))
//    println(tree.getWidth(root))
//    println(tree.getMax(root))
//    tree.swap(root)
//    tree.orderTree(root,BinaryTree.BinaryType.LEVEL)
//    tree.deleteLeaves(root)
//    tree.orderTree(root,BinaryTree.BinaryType.LEVEL)
//    println(tree.isComplete(root))
    var pre = listOf(1,2,4,5,6,7,8,3,9,10,11,12)
    var mid = listOf(4,2,6,7,5,8,1,3,11,10,12,9)
    tree.createTree1(pre,mid)
    tree.orderTree(tree.root,BinaryTree.BinaryType.LEVEL)
}